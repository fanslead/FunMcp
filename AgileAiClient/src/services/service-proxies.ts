//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AgentService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param applicationId (optional) 
     * @return OK
     */
    agentAll(applicationId: string | undefined): Promise<Agent[]> {
        let url_ = this.baseUrl + "/api/Agent?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgentAll(_response);
        });
    }

    protected processAgentAll(response: Response): Promise<Agent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Agent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Agent[]>(null as any);
    }

    /**
     * @return Created
     */
    agentPOST(body: AgentCreateDto): Promise<CreatedOfAgent> {
        let url_ = this.baseUrl + "/api/Agent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgentPOST(_response);
        });
    }

    protected processAgentPOST(response: Response): Promise<CreatedOfAgent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedOfAgent.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatedOfAgent>(null as any);
    }

    /**
     * @return OK
     */
    agentGET(id: string): Promise<Agent> {
        let url_ = this.baseUrl + "/api/Agent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgentGET(_response);
        });
    }

    protected processAgentGET(response: Response): Promise<Agent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Agent.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Agent>(null as any);
    }

    /**
     * @return No Content
     */
    agentPUT(id: string, body: AgentUpdateDto): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Agent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgentPUT(_response);
        });
    }

    protected processAgentPUT(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return No Content
     */
    agentDELETE(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Agent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAgentDELETE(_response);
        });
    }

    protected processAgentDELETE(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }
}

export class AIConfigService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    aIConfig(): Promise<AIConfigDto[]> {
        let url_ = this.baseUrl + "/api/AIConfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAIConfig(_response);
        });
    }

    protected processAIConfig(response: Response): Promise<AIConfigDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AIConfigDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AIConfigDto[]>(null as any);
    }
}

export class ApplicationService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filter (optional) 
     * @return OK
     */
    applicationAll(filter: string | undefined): Promise<Application2[]> {
        let url_ = this.baseUrl + "/api/Application?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationAll(_response);
        });
    }

    protected processApplicationAll(response: Response): Promise<Application2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Application2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application2[]>(null as any);
    }

    /**
     * @return Created
     */
    applicationPOST(body: ApplicationCreateDto): Promise<CreatedOfApplication> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPOST(_response);
        });
    }

    protected processApplicationPOST(response: Response): Promise<CreatedOfApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedOfApplication.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatedOfApplication>(null as any);
    }

    /**
     * @return OK
     */
    applicationGET(id: string): Promise<OkOfApplication> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationGET(_response);
        });
    }

    protected processApplicationGET(response: Response): Promise<OkOfApplication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OkOfApplication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OkOfApplication>(null as any);
    }

    /**
     * @return No Content
     */
    applicationPUT(id: string, body: ApplicationUpdateDto): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPUT(_response);
        });
    }

    protected processApplicationPUT(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return No Content
     */
    applicationDELETE(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationDELETE(_response);
        });
    }

    protected processApplicationDELETE(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return No Content
     */
    refreshApiKey(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/Application/RefreshApiKey/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshApiKey(_response);
        });
    }

    protected processRefreshApiKey(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }
}

export class ChatService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    chat(body: ChatRequestDto): Promise<ChatResponseUpdate[]> {
        let url_ = this.baseUrl + "/api/Chat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChat(_response);
        });
    }

    protected processChat(response: Response): Promise<ChatResponseUpdate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChatResponseUpdate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatResponseUpdate[]>(null as any);
    }

    /**
     * @return OK
     */
    tools(agentId: string): Promise<{ [key: string]: McpClientToolDto[]; }> {
        let url_ = this.baseUrl + "/api/Chat/agent/tools/{agentId}";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTools(_response);
        });
    }

    protected processTools(response: Response): Promise<{ [key: string]: McpClientToolDto[]; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => McpClientToolDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: McpClientToolDto[]; }>(null as any);
    }

    /**
     * @return OK
     */
    toolsAll(agentId: string, mcpId: string): Promise<McpClientToolDto[]> {
        let url_ = this.baseUrl + "/api/Chat/agent/tools/{agentId}/{mcpId}";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        if (mcpId === undefined || mcpId === null)
            throw new Error("The parameter 'mcpId' must be defined.");
        url_ = url_.replace("{mcpId}", encodeURIComponent("" + mcpId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToolsAll(_response);
        });
    }

    protected processToolsAll(response: Response): Promise<McpClientToolDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(McpClientToolDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<McpClientToolDto[]>(null as any);
    }

    /**
     * @return OK
     */
    mcp(agentId: string): Promise<{ [key: string]: McpServerInfoDto; }> {
        let url_ = this.baseUrl + "/api/Chat/agent/mcp/{agentId}";
        if (agentId === undefined || agentId === null)
            throw new Error("The parameter 'agentId' must be defined.");
        url_ = url_.replace("{agentId}", encodeURIComponent("" + agentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcp(_response);
        });
    }

    protected processMcp(response: Response): Promise<{ [key: string]: McpServerInfoDto; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? McpServerInfoDto.fromJS(resultData200[key]) : new McpServerInfoDto();
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: McpServerInfoDto; }>(null as any);
    }
}

export class McpServerService {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param filter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    mcpServerAll(filter: string | undefined, pageNumber: number | undefined, pageSize: number | undefined): Promise<McpServer2[]> {
        let url_ = this.baseUrl + "/api/McpServer?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcpServerAll(_response);
        });
    }

    protected processMcpServerAll(response: Response): Promise<McpServer2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(McpServer2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<McpServer2[]>(null as any);
    }

    /**
     * @return Created
     */
    mcpServerPOST(body: McpServerCreateDto): Promise<CreatedOfMcpServer> {
        let url_ = this.baseUrl + "/api/McpServer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcpServerPOST(_response);
        });
    }

    protected processMcpServerPOST(response: Response): Promise<CreatedOfMcpServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedOfMcpServer.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatedOfMcpServer>(null as any);
    }

    /**
     * @return OK
     */
    mcpServerGET(id: string): Promise<OkOfMcpServer> {
        let url_ = this.baseUrl + "/api/McpServer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcpServerGET(_response);
        });
    }

    protected processMcpServerGET(response: Response): Promise<OkOfMcpServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OkOfMcpServer.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OkOfMcpServer>(null as any);
    }

    /**
     * @return No Content
     */
    mcpServerPUT(id: string, body: McpServerUpdateDto): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/McpServer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcpServerPUT(_response);
        });
    }

    protected processMcpServerPUT(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return No Content
     */
    mcpServerDELETE(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/McpServer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMcpServerDELETE(_response);
        });
    }

    protected processMcpServerDELETE(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return Created
     */
    import(body: ImportMcpServerDto): Promise<CreatedOfMcpServer> {
        let url_ = this.baseUrl + "/api/McpServer/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<CreatedOfMcpServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedOfMcpServer.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreatedOfMcpServer>(null as any);
    }

    /**
     * @return OK
     */
    batchImport(body: BatchImportMcpServerDto): Promise<void> {
        let url_ = this.baseUrl + "/api/McpServer/Batch-Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchImport(_response);
        });
    }

    protected processBatchImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    enable(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/McpServer/Enable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnable(_response);
        });
    }

    protected processEnable(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return No Content
     */
    disable(id: string): Promise<NoContent> {
        let url_ = this.baseUrl + "/api/McpServer/Disable/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDisable(_response);
        });
    }

    protected processDisable(response: Response): Promise<NoContent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = NoContent.fromJS(resultData204);
            return result204;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoContent>(null as any);
    }

    /**
     * @return OK
     */
    toolsAll2(id: string): Promise<McpClientToolDto[]> {
        let url_ = this.baseUrl + "/api/McpServer/tools/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToolsAll2(_response);
        });
    }

    protected processToolsAll2(response: Response): Promise<McpClientToolDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(McpClientToolDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<McpClientToolDto[]>(null as any);
    }

    /**
     * @return OK
     */
    tags(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/McpServer/tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags(_response);
        });
    }

    protected processTags(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }
}

export class Agent implements IAgent {
    id!: string;
    applicationId!: string;
    application?: Application | undefined;
    name!: string;
    description?: string | undefined;
    systemPrompt!: string;
    aiServer!: string;
    modelId!: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    applicationMcpServers?: AgentMcpServer[] | undefined;

    [key: string]: any;

    constructor(data?: IAgent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.systemPrompt = _data["systemPrompt"];
            this.aiServer = _data["aiServer"];
            this.modelId = _data["modelId"];
            this.temperature = _data["temperature"];
            this.maxOutputTokens = _data["maxOutputTokens"];
            this.topP = _data["topP"];
            if (Array.isArray(_data["applicationMcpServers"])) {
                this.applicationMcpServers = [] as any;
                for (let item of _data["applicationMcpServers"])
                    this.applicationMcpServers!.push(AgentMcpServer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Agent {
        data = typeof data === 'object' ? data : {};
        let result = new Agent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["systemPrompt"] = this.systemPrompt;
        data["aiServer"] = this.aiServer;
        data["modelId"] = this.modelId;
        data["temperature"] = this.temperature;
        data["maxOutputTokens"] = this.maxOutputTokens;
        data["topP"] = this.topP;
        if (Array.isArray(this.applicationMcpServers)) {
            data["applicationMcpServers"] = [];
            for (let item of this.applicationMcpServers)
                data["applicationMcpServers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgent {
    id: string;
    applicationId: string;
    application?: Application | undefined;
    name: string;
    description?: string | undefined;
    systemPrompt: string;
    aiServer: string;
    modelId: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    applicationMcpServers?: AgentMcpServer[] | undefined;

    [key: string]: any;
}

export class Agent2 implements IAgent2 {
    id!: string;
    applicationId!: string;
    application?: any | undefined;
    name!: string;
    description?: string | undefined;
    systemPrompt!: string;
    aiServer!: string;
    modelId!: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    applicationMcpServers?: AgentMcpServer[] | undefined;

    [key: string]: any;

    constructor(data?: IAgent2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.systemPrompt = _data["systemPrompt"];
            this.aiServer = _data["aiServer"];
            this.modelId = _data["modelId"];
            this.temperature = _data["temperature"];
            this.maxOutputTokens = _data["maxOutputTokens"];
            this.topP = _data["topP"];
            if (Array.isArray(_data["applicationMcpServers"])) {
                this.applicationMcpServers = [] as any;
                for (let item of _data["applicationMcpServers"])
                    this.applicationMcpServers!.push(AgentMcpServer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Agent2 {
        data = typeof data === 'object' ? data : {};
        let result = new Agent2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application;
        data["name"] = this.name;
        data["description"] = this.description;
        data["systemPrompt"] = this.systemPrompt;
        data["aiServer"] = this.aiServer;
        data["modelId"] = this.modelId;
        data["temperature"] = this.temperature;
        data["maxOutputTokens"] = this.maxOutputTokens;
        data["topP"] = this.topP;
        if (Array.isArray(this.applicationMcpServers)) {
            data["applicationMcpServers"] = [];
            for (let item of this.applicationMcpServers)
                data["applicationMcpServers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgent2 {
    id: string;
    applicationId: string;
    application?: any | undefined;
    name: string;
    description?: string | undefined;
    systemPrompt: string;
    aiServer: string;
    modelId: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    applicationMcpServers?: AgentMcpServer[] | undefined;

    [key: string]: any;
}

export class AgentCreateDto implements IAgentCreateDto {
    applicationId!: string;
    name!: string;
    description?: string | undefined;
    systemPrompt!: string;
    aiServer!: string;
    modelId!: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    mcpServers?: string[] | undefined;
    mcpServerTools?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IAgentCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.applicationId = _data["applicationId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.systemPrompt = _data["systemPrompt"];
            this.aiServer = _data["aiServer"];
            this.modelId = _data["modelId"];
            this.temperature = _data["temperature"];
            this.maxOutputTokens = _data["maxOutputTokens"];
            this.topP = _data["topP"];
            if (Array.isArray(_data["mcpServers"])) {
                this.mcpServers = [] as any;
                for (let item of _data["mcpServers"])
                    this.mcpServers!.push(item);
            }
            if (_data["mcpServerTools"]) {
                this.mcpServerTools = {} as any;
                for (let key in _data["mcpServerTools"]) {
                    if (_data["mcpServerTools"].hasOwnProperty(key))
                        (<any>this.mcpServerTools)![key] = _data["mcpServerTools"][key] !== undefined ? _data["mcpServerTools"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): AgentCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgentCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["applicationId"] = this.applicationId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["systemPrompt"] = this.systemPrompt;
        data["aiServer"] = this.aiServer;
        data["modelId"] = this.modelId;
        data["temperature"] = this.temperature;
        data["maxOutputTokens"] = this.maxOutputTokens;
        data["topP"] = this.topP;
        if (Array.isArray(this.mcpServers)) {
            data["mcpServers"] = [];
            for (let item of this.mcpServers)
                data["mcpServers"].push(item);
        }
        if (this.mcpServerTools) {
            data["mcpServerTools"] = {};
            for (let key in this.mcpServerTools) {
                if (this.mcpServerTools.hasOwnProperty(key))
                    (<any>data["mcpServerTools"])[key] = (<any>this.mcpServerTools)[key];
            }
        }
        return data;
    }
}

export interface IAgentCreateDto {
    applicationId: string;
    name: string;
    description?: string | undefined;
    systemPrompt: string;
    aiServer: string;
    modelId: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    mcpServers?: string[] | undefined;
    mcpServerTools?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class AgentMcpServer implements IAgentMcpServer {
    agentId!: string;
    agent?: Agent2 | undefined;
    mcpServerId!: string;
    mcpServer?: McpServer | undefined;
    mcpServerTools?: string[];

    [key: string]: any;

    constructor(data?: IAgentMcpServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.agentId = _data["agentId"];
            this.agent = _data["agent"] ? Agent2.fromJS(_data["agent"]) : <any>undefined;
            this.mcpServerId = _data["mcpServerId"];
            this.mcpServer = _data["mcpServer"] ? McpServer.fromJS(_data["mcpServer"]) : <any>undefined;
            if (Array.isArray(_data["mcpServerTools"])) {
                this.mcpServerTools = [] as any;
                for (let item of _data["mcpServerTools"])
                    this.mcpServerTools!.push(item);
            }
        }
    }

    static fromJS(data: any): AgentMcpServer {
        data = typeof data === 'object' ? data : {};
        let result = new AgentMcpServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["agentId"] = this.agentId;
        data["agent"] = this.agent ? this.agent.toJSON() : <any>undefined;
        data["mcpServerId"] = this.mcpServerId;
        data["mcpServer"] = this.mcpServer ? this.mcpServer.toJSON() : <any>undefined;
        if (Array.isArray(this.mcpServerTools)) {
            data["mcpServerTools"] = [];
            for (let item of this.mcpServerTools)
                data["mcpServerTools"].push(item);
        }
        return data;
    }
}

export interface IAgentMcpServer {
    agentId: string;
    agent?: Agent2 | undefined;
    mcpServerId: string;
    mcpServer?: McpServer | undefined;
    mcpServerTools?: string[];

    [key: string]: any;
}

export class AgentUpdateDto implements IAgentUpdateDto {
    name!: string;
    description?: string | undefined;
    systemPrompt!: string;
    aiServer!: string;
    modelId!: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    mcpServers?: string[] | undefined;
    mcpServerTools?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IAgentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.systemPrompt = _data["systemPrompt"];
            this.aiServer = _data["aiServer"];
            this.modelId = _data["modelId"];
            this.temperature = _data["temperature"];
            this.maxOutputTokens = _data["maxOutputTokens"];
            this.topP = _data["topP"];
            if (Array.isArray(_data["mcpServers"])) {
                this.mcpServers = [] as any;
                for (let item of _data["mcpServers"])
                    this.mcpServers!.push(item);
            }
            if (_data["mcpServerTools"]) {
                this.mcpServerTools = {} as any;
                for (let key in _data["mcpServerTools"]) {
                    if (_data["mcpServerTools"].hasOwnProperty(key))
                        (<any>this.mcpServerTools)![key] = _data["mcpServerTools"][key] !== undefined ? _data["mcpServerTools"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): AgentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["systemPrompt"] = this.systemPrompt;
        data["aiServer"] = this.aiServer;
        data["modelId"] = this.modelId;
        data["temperature"] = this.temperature;
        data["maxOutputTokens"] = this.maxOutputTokens;
        data["topP"] = this.topP;
        if (Array.isArray(this.mcpServers)) {
            data["mcpServers"] = [];
            for (let item of this.mcpServers)
                data["mcpServers"].push(item);
        }
        if (this.mcpServerTools) {
            data["mcpServerTools"] = {};
            for (let key in this.mcpServerTools) {
                if (this.mcpServerTools.hasOwnProperty(key))
                    (<any>data["mcpServerTools"])[key] = (<any>this.mcpServerTools)[key];
            }
        }
        return data;
    }
}

export interface IAgentUpdateDto {
    name: string;
    description?: string | undefined;
    systemPrompt: string;
    aiServer: string;
    modelId: string;
    temperature?: number | undefined;
    maxOutputTokens?: number | undefined;
    topP?: number | undefined;
    mcpServers?: string[] | undefined;
    mcpServerTools?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class AIConfigDto implements IAIConfigDto {
    name!: string;
    models?: AIModelDto[];

    [key: string]: any;

    constructor(data?: IAIConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(AIModelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AIConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AIConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAIConfigDto {
    name: string;
    models?: AIModelDto[];

    [key: string]: any;
}

export class AIContent implements IAIContent {

    [key: string]: any;

    constructor(data?: IAIContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AIContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAIContent {

    [key: string]: any;
}

export class AIContentBase implements IAIContentBase {
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentBase {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentBase {
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentDataContent implements IAIContentDataContent {
    $type!: AIContentDataContent_type;
    uri!: string;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentDataContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.uri = _data["uri"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentDataContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentDataContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["uri"] = this.uri;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentDataContent {
    $type: AIContentDataContent_type;
    uri: string;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentErrorContent implements IAIContentErrorContent {
    $type!: AIContentErrorContent_type;
    message!: string | undefined;
    errorCode?: string | undefined;
    details?: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentErrorContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.message = _data["message"];
            this.errorCode = _data["errorCode"];
            this.details = _data["details"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentErrorContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentErrorContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["details"] = this.details;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentErrorContent {
    $type: AIContentErrorContent_type;
    message: string | undefined;
    errorCode?: string | undefined;
    details?: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentFunctionCallContent implements IAIContentFunctionCallContent {
    $type!: AIContentFunctionCallContent_type;
    callId!: string;
    name!: string;
    arguments?: any | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentFunctionCallContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.callId = _data["callId"];
            this.name = _data["name"];
            this.arguments = _data["arguments"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentFunctionCallContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentFunctionCallContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["callId"] = this.callId;
        data["name"] = this.name;
        data["arguments"] = this.arguments;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentFunctionCallContent {
    $type: AIContentFunctionCallContent_type;
    callId: string;
    name: string;
    arguments?: any | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentFunctionResultContent implements IAIContentFunctionResultContent {
    $type!: AIContentFunctionResultContent_type;
    callId!: string;
    result!: any;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentFunctionResultContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.callId = _data["callId"];
            this.result = _data["result"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentFunctionResultContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentFunctionResultContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["callId"] = this.callId;
        data["result"] = this.result;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentFunctionResultContent {
    $type: AIContentFunctionResultContent_type;
    callId: string;
    result: any;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentTextContent implements IAIContentTextContent {
    $type!: AIContentTextContent_type;
    text!: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentTextContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.text = _data["text"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentTextContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentTextContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["text"] = this.text;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentTextContent {
    $type: AIContentTextContent_type;
    text: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentTextReasoningContent implements IAIContentTextReasoningContent {
    $type!: AIContentTextReasoningContent_type;
    text!: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentTextReasoningContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.text = _data["text"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentTextReasoningContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentTextReasoningContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["text"] = this.text;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentTextReasoningContent {
    $type: AIContentTextReasoningContent_type;
    text: string | undefined;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentUriContent implements IAIContentUriContent {
    $type!: AIContentUriContent_type;
    uri!: string;
    mediaType!: string;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentUriContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.uri = _data["uri"];
            this.mediaType = _data["mediaType"];
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentUriContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentUriContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["uri"] = this.uri;
        data["mediaType"] = this.mediaType;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentUriContent {
    $type: AIContentUriContent_type;
    uri: string;
    mediaType: string;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIContentUsageContent implements IAIContentUsageContent {
    $type!: AIContentUsageContent_type;
    details!: Details;
    additionalProperties?: any | undefined;

    [key: string]: any;

    constructor(data?: IAIContentUsageContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.details = new Details();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.$type = _data["$type"];
            this.details = _data["details"] ? Details.fromJS(_data["details"]) : new Details();
            this.additionalProperties = _data["additionalProperties"];
        }
    }

    static fromJS(data: any): AIContentUsageContent {
        data = typeof data === 'object' ? data : {};
        let result = new AIContentUsageContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["$type"] = this.$type;
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["additionalProperties"] = this.additionalProperties;
        return data;
    }
}

export interface IAIContentUsageContent {
    $type: AIContentUsageContent_type;
    details: Details;
    additionalProperties?: any | undefined;

    [key: string]: any;
}

export class AIModelDto implements IAIModelDto {
    name!: string;
    modelId!: string;

    [key: string]: any;

    constructor(data?: IAIModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.modelId = _data["modelId"];
        }
    }

    static fromJS(data: any): AIModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new AIModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["modelId"] = this.modelId;
        return data;
    }
}

export interface IAIModelDto {
    name: string;
    modelId: string;

    [key: string]: any;
}

export class Application implements IApplication {
    id!: string;
    name!: string;
    description?: string | undefined;
    apiKey!: string;

    [key: string]: any;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IApplication {
    id: string;
    name: string;
    description?: string | undefined;
    apiKey: string;

    [key: string]: any;
}

export class Application2 implements IApplication2 {
    id!: string;
    name!: string;
    description?: string | undefined;
    apiKey!: string;

    [key: string]: any;

    constructor(data?: IApplication2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): Application2 {
        data = typeof data === 'object' ? data : {};
        let result = new Application2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

export interface IApplication2 {
    id: string;
    name: string;
    description?: string | undefined;
    apiKey: string;

    [key: string]: any;
}

export class ApplicationCreateDto implements IApplicationCreateDto {
    name!: string;
    description?: string | undefined;

    [key: string]: any;

    constructor(data?: IApplicationCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ApplicationCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IApplicationCreateDto {
    name: string;
    description?: string | undefined;

    [key: string]: any;
}

export class ApplicationUpdateDto implements IApplicationUpdateDto {
    name!: string;
    description?: string | undefined;

    [key: string]: any;

    constructor(data?: IApplicationUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ApplicationUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IApplicationUpdateDto {
    name: string;
    description?: string | undefined;

    [key: string]: any;
}

export class BatchImportMcpServerDto implements IBatchImportMcpServerDto {
    json?: string;

    [key: string]: any;

    constructor(data?: IBatchImportMcpServerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.json = _data["json"];
        }
    }

    static fromJS(data: any): BatchImportMcpServerDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchImportMcpServerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["json"] = this.json;
        return data;
    }
}

export interface IBatchImportMcpServerDto {
    json?: string;

    [key: string]: any;
}

export class ChatMessageDto implements IChatMessageDto {
    role!: string;
    content!: string;

    [key: string]: any;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role;
        data["content"] = this.content;
        return data;
    }
}

export interface IChatMessageDto {
    role: string;
    content: string;

    [key: string]: any;
}

export class ChatRequestDto implements IChatRequestDto {
    agentId!: string;
    chatMessages!: ChatMessageDto[];

    [key: string]: any;

    constructor(data?: IChatRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.chatMessages = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.agentId = _data["agentId"];
            if (Array.isArray(_data["chatMessages"])) {
                this.chatMessages = [] as any;
                for (let item of _data["chatMessages"])
                    this.chatMessages!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChatRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["agentId"] = this.agentId;
        if (Array.isArray(this.chatMessages)) {
            data["chatMessages"] = [];
            for (let item of this.chatMessages)
                data["chatMessages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChatRequestDto {
    agentId: string;
    chatMessages: ChatMessageDto[];

    [key: string]: any;
}

export class ChatResponseUpdate implements IChatResponseUpdate {
    authorName?: string | undefined;
    role?: NullableOfChatRole | undefined;
    contents?: AIContent[] | undefined;
    additionalProperties?: any | undefined;
    responseId?: string | undefined;
    messageId?: string | undefined;
    conversationId?: string | undefined;
    createdAt?: Date | undefined;
    finishReason?: NullableOfChatFinishReason | undefined;
    modelId?: string | undefined;

    [key: string]: any;

    constructor(data?: IChatResponseUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.authorName = _data["authorName"];
            this.role = _data["role"] ? NullableOfChatRole.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["contents"])) {
                this.contents = [] as any;
                for (let item of _data["contents"])
                    this.contents!.push(AIContent.fromJS(item));
            }
            this.additionalProperties = _data["additionalProperties"];
            this.responseId = _data["responseId"];
            this.messageId = _data["messageId"];
            this.conversationId = _data["conversationId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.finishReason = _data["finishReason"] ? NullableOfChatFinishReason.fromJS(_data["finishReason"]) : <any>undefined;
            this.modelId = _data["modelId"];
        }
    }

    static fromJS(data: any): ChatResponseUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponseUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["authorName"] = this.authorName;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.contents)) {
            data["contents"] = [];
            for (let item of this.contents)
                data["contents"].push(item.toJSON());
        }
        data["additionalProperties"] = this.additionalProperties;
        data["responseId"] = this.responseId;
        data["messageId"] = this.messageId;
        data["conversationId"] = this.conversationId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["finishReason"] = this.finishReason ? this.finishReason.toJSON() : <any>undefined;
        data["modelId"] = this.modelId;
        return data;
    }
}

export interface IChatResponseUpdate {
    authorName?: string | undefined;
    role?: NullableOfChatRole | undefined;
    contents?: AIContent[] | undefined;
    additionalProperties?: any | undefined;
    responseId?: string | undefined;
    messageId?: string | undefined;
    conversationId?: string | undefined;
    createdAt?: Date | undefined;
    finishReason?: NullableOfChatFinishReason | undefined;
    modelId?: string | undefined;

    [key: string]: any;
}

export class CreatedOfAgent implements ICreatedOfAgent {
    value?: Agent2 | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;

    constructor(data?: ICreatedOfAgent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? Agent2.fromJS(_data["value"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreatedOfAgent {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedOfAgent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        data["location"] = this.location;
        return data;
    }
}

export interface ICreatedOfAgent {
    value?: Agent2 | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;
}

export class CreatedOfApplication implements ICreatedOfApplication {
    value?: Application | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;

    constructor(data?: ICreatedOfApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? Application.fromJS(_data["value"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreatedOfApplication {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedOfApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        data["location"] = this.location;
        return data;
    }
}

export interface ICreatedOfApplication {
    value?: Application | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;
}

export class CreatedOfMcpServer implements ICreatedOfMcpServer {
    value?: McpServer | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;

    constructor(data?: ICreatedOfMcpServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? McpServer.fromJS(_data["value"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreatedOfMcpServer {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedOfMcpServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        data["location"] = this.location;
        return data;
    }
}

export interface ICreatedOfMcpServer {
    value?: McpServer | undefined;
    statusCode?: number;
    location?: string | undefined;

    [key: string]: any;
}

export class ImportMcpServerDto implements IImportMcpServerDto {
    name!: string;
    json!: string;

    [key: string]: any;

    constructor(data?: IImportMcpServerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.json = _data["json"];
        }
    }

    static fromJS(data: any): ImportMcpServerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportMcpServerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["json"] = this.json;
        return data;
    }
}

export interface IImportMcpServerDto {
    name: string;
    json: string;

    [key: string]: any;
}

export class McpClientToolDto implements IMcpClientToolDto {
    name?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: IMcpClientToolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): McpClientToolDto {
        data = typeof data === 'object' ? data : {};
        let result = new McpClientToolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IMcpClientToolDto {
    name?: string;
    description?: string;

    [key: string]: any;
}

export class McpServer implements IMcpServer {
    id!: string;
    name!: string;
    transportType!: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    useStreamableHttp?: boolean;
    enable?: boolean;
    description?: string | undefined;
    tag?: string | undefined;

    [key: string]: any;

    constructor(data?: IMcpServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.transportType = _data["transportType"];
            this.command = _data["command"];
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
            if (_data["environmentVariables"]) {
                this.environmentVariables = {} as any;
                for (let key in _data["environmentVariables"]) {
                    if (_data["environmentVariables"].hasOwnProperty(key))
                        (<any>this.environmentVariables)![key] = _data["environmentVariables"][key];
                }
            }
            this.endpoint = _data["endpoint"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.connectionTimeout = _data["connectionTimeout"];
            this.useStreamableHttp = _data["useStreamableHttp"];
            this.enable = _data["enable"];
            this.description = _data["description"];
            this.tag = _data["tag"];
        }
    }

    static fromJS(data: any): McpServer {
        data = typeof data === 'object' ? data : {};
        let result = new McpServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["transportType"] = this.transportType;
        data["command"] = this.command;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        if (this.environmentVariables) {
            data["environmentVariables"] = {};
            for (let key in this.environmentVariables) {
                if (this.environmentVariables.hasOwnProperty(key))
                    (<any>data["environmentVariables"])[key] = (<any>this.environmentVariables)[key];
            }
        }
        data["endpoint"] = this.endpoint;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["connectionTimeout"] = this.connectionTimeout;
        data["useStreamableHttp"] = this.useStreamableHttp;
        data["enable"] = this.enable;
        data["description"] = this.description;
        data["tag"] = this.tag;
        return data;
    }
}

export interface IMcpServer {
    id: string;
    name: string;
    transportType: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    useStreamableHttp?: boolean;
    enable?: boolean;
    description?: string | undefined;
    tag?: string | undefined;

    [key: string]: any;
}

export class McpServer2 implements IMcpServer2 {
    id!: string;
    name!: string;
    transportType!: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    useStreamableHttp?: boolean;
    enable?: boolean;
    description?: string | undefined;
    tag?: string | undefined;

    [key: string]: any;

    constructor(data?: IMcpServer2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.transportType = _data["transportType"];
            this.command = _data["command"];
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
            if (_data["environmentVariables"]) {
                this.environmentVariables = {} as any;
                for (let key in _data["environmentVariables"]) {
                    if (_data["environmentVariables"].hasOwnProperty(key))
                        (<any>this.environmentVariables)![key] = _data["environmentVariables"][key];
                }
            }
            this.endpoint = _data["endpoint"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.connectionTimeout = _data["connectionTimeout"];
            this.useStreamableHttp = _data["useStreamableHttp"];
            this.enable = _data["enable"];
            this.description = _data["description"];
            this.tag = _data["tag"];
        }
    }

    static fromJS(data: any): McpServer2 {
        data = typeof data === 'object' ? data : {};
        let result = new McpServer2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["transportType"] = this.transportType;
        data["command"] = this.command;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        if (this.environmentVariables) {
            data["environmentVariables"] = {};
            for (let key in this.environmentVariables) {
                if (this.environmentVariables.hasOwnProperty(key))
                    (<any>data["environmentVariables"])[key] = (<any>this.environmentVariables)[key];
            }
        }
        data["endpoint"] = this.endpoint;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["connectionTimeout"] = this.connectionTimeout;
        data["useStreamableHttp"] = this.useStreamableHttp;
        data["enable"] = this.enable;
        data["description"] = this.description;
        data["tag"] = this.tag;
        return data;
    }
}

export interface IMcpServer2 {
    id: string;
    name: string;
    transportType: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    useStreamableHttp?: boolean;
    enable?: boolean;
    description?: string | undefined;
    tag?: string | undefined;

    [key: string]: any;
}

export class McpServerCreateDto implements IMcpServerCreateDto {
    name!: string;
    transportType!: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    maxReconnectAttempts?: number | undefined;
    reconnectDelay?: number | undefined;
    connectionTimeout?: number | undefined;
    description?: string | undefined;
    tag?: string | undefined;
    useStreamableHttp?: boolean | undefined;

    [key: string]: any;

    constructor(data?: IMcpServerCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.transportType = _data["transportType"];
            this.command = _data["command"];
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
            if (_data["environmentVariables"]) {
                this.environmentVariables = {} as any;
                for (let key in _data["environmentVariables"]) {
                    if (_data["environmentVariables"].hasOwnProperty(key))
                        (<any>this.environmentVariables)![key] = _data["environmentVariables"][key];
                }
            }
            this.endpoint = _data["endpoint"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.maxReconnectAttempts = _data["maxReconnectAttempts"];
            this.reconnectDelay = _data["reconnectDelay"];
            this.connectionTimeout = _data["connectionTimeout"];
            this.description = _data["description"];
            this.tag = _data["tag"];
            this.useStreamableHttp = _data["useStreamableHttp"];
        }
    }

    static fromJS(data: any): McpServerCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new McpServerCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["transportType"] = this.transportType;
        data["command"] = this.command;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        if (this.environmentVariables) {
            data["environmentVariables"] = {};
            for (let key in this.environmentVariables) {
                if (this.environmentVariables.hasOwnProperty(key))
                    (<any>data["environmentVariables"])[key] = (<any>this.environmentVariables)[key];
            }
        }
        data["endpoint"] = this.endpoint;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["maxReconnectAttempts"] = this.maxReconnectAttempts;
        data["reconnectDelay"] = this.reconnectDelay;
        data["connectionTimeout"] = this.connectionTimeout;
        data["description"] = this.description;
        data["tag"] = this.tag;
        data["useStreamableHttp"] = this.useStreamableHttp;
        return data;
    }
}

export interface IMcpServerCreateDto {
    name: string;
    transportType: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    maxReconnectAttempts?: number | undefined;
    reconnectDelay?: number | undefined;
    connectionTimeout?: number | undefined;
    description?: string | undefined;
    tag?: string | undefined;
    useStreamableHttp?: boolean | undefined;

    [key: string]: any;
}

export class McpServerInfoDto implements IMcpServerInfoDto {
    id!: string;
    name!: string;
    version!: string;

    [key: string]: any;

    constructor(data?: IMcpServerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): McpServerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new McpServerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["version"] = this.version;
        return data;
    }
}

export interface IMcpServerInfoDto {
    id: string;
    name: string;
    version: string;

    [key: string]: any;
}

export class McpServerUpdateDto implements IMcpServerUpdateDto {
    name!: string;
    transportType!: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    description?: string | undefined;
    tag?: string | undefined;
    useStreamableHttp?: boolean | undefined;

    [key: string]: any;

    constructor(data?: IMcpServerUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.transportType = _data["transportType"];
            this.command = _data["command"];
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
            if (_data["environmentVariables"]) {
                this.environmentVariables = {} as any;
                for (let key in _data["environmentVariables"]) {
                    if (_data["environmentVariables"].hasOwnProperty(key))
                        (<any>this.environmentVariables)![key] = _data["environmentVariables"][key];
                }
            }
            this.endpoint = _data["endpoint"];
            if (_data["additionalHeaders"]) {
                this.additionalHeaders = {} as any;
                for (let key in _data["additionalHeaders"]) {
                    if (_data["additionalHeaders"].hasOwnProperty(key))
                        (<any>this.additionalHeaders)![key] = _data["additionalHeaders"][key];
                }
            }
            this.connectionTimeout = _data["connectionTimeout"];
            this.description = _data["description"];
            this.tag = _data["tag"];
            this.useStreamableHttp = _data["useStreamableHttp"];
        }
    }

    static fromJS(data: any): McpServerUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new McpServerUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["transportType"] = this.transportType;
        data["command"] = this.command;
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        if (this.environmentVariables) {
            data["environmentVariables"] = {};
            for (let key in this.environmentVariables) {
                if (this.environmentVariables.hasOwnProperty(key))
                    (<any>data["environmentVariables"])[key] = (<any>this.environmentVariables)[key];
            }
        }
        data["endpoint"] = this.endpoint;
        if (this.additionalHeaders) {
            data["additionalHeaders"] = {};
            for (let key in this.additionalHeaders) {
                if (this.additionalHeaders.hasOwnProperty(key))
                    (<any>data["additionalHeaders"])[key] = (<any>this.additionalHeaders)[key];
            }
        }
        data["connectionTimeout"] = this.connectionTimeout;
        data["description"] = this.description;
        data["tag"] = this.tag;
        data["useStreamableHttp"] = this.useStreamableHttp;
        return data;
    }
}

export interface IMcpServerUpdateDto {
    name: string;
    transportType: string;
    command?: string | undefined;
    arguments?: string[] | undefined;
    environmentVariables?: { [key: string]: string; } | undefined;
    endpoint?: string | undefined;
    additionalHeaders?: { [key: string]: string; } | undefined;
    connectionTimeout?: number | undefined;
    description?: string | undefined;
    tag?: string | undefined;
    useStreamableHttp?: boolean | undefined;

    [key: string]: any;
}

export class NoContent implements INoContent {
    statusCode?: number;

    [key: string]: any;

    constructor(data?: INoContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): NoContent {
        data = typeof data === 'object' ? data : {};
        let result = new NoContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface INoContent {
    statusCode?: number;

    [key: string]: any;
}

export class NullableOfChatFinishReason implements INullableOfChatFinishReason {

    [key: string]: any;

    constructor(data?: INullableOfChatFinishReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): NullableOfChatFinishReason {
        data = typeof data === 'object' ? data : {};
        let result = new NullableOfChatFinishReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface INullableOfChatFinishReason {

    [key: string]: any;
}

export class NullableOfChatRole implements INullableOfChatRole {

    [key: string]: any;

    constructor(data?: INullableOfChatRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): NullableOfChatRole {
        data = typeof data === 'object' ? data : {};
        let result = new NullableOfChatRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface INullableOfChatRole {

    [key: string]: any;
}

export class OkOfApplication implements IOkOfApplication {
    value?: Application | undefined;
    statusCode?: number;

    [key: string]: any;

    constructor(data?: IOkOfApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? Application.fromJS(_data["value"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): OkOfApplication {
        data = typeof data === 'object' ? data : {};
        let result = new OkOfApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IOkOfApplication {
    value?: Application | undefined;
    statusCode?: number;

    [key: string]: any;
}

export class OkOfMcpServer implements IOkOfMcpServer {
    value?: McpServer | undefined;
    statusCode?: number;

    [key: string]: any;

    constructor(data?: IOkOfMcpServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? McpServer.fromJS(_data["value"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): OkOfMcpServer {
        data = typeof data === 'object' ? data : {};
        let result = new OkOfMcpServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IOkOfMcpServer {
    value?: McpServer | undefined;
    statusCode?: number;

    [key: string]: any;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum AIContentDataContent_type {
    Data = "data",
}

export enum AIContentErrorContent_type {
    Error = "error",
}

export enum AIContentFunctionCallContent_type {
    FunctionCall = "functionCall",
}

export enum AIContentFunctionResultContent_type {
    FunctionResult = "functionResult",
}

export enum AIContentTextContent_type {
    Text = "text",
}

export enum AIContentTextReasoningContent_type {
    Reasoning = "reasoning",
}

export enum AIContentUriContent_type {
    Uri = "uri",
}

export enum AIContentUsageContent_type {
    Usage = "usage",
}

export class Details implements IDetails {
    inputTokenCount?: number | undefined;
    outputTokenCount?: number | undefined;
    totalTokenCount?: number | undefined;
    additionalCounts?: { [key: string]: number; } | undefined;

    [key: string]: any;

    constructor(data?: IDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.inputTokenCount = _data["inputTokenCount"];
            this.outputTokenCount = _data["outputTokenCount"];
            this.totalTokenCount = _data["totalTokenCount"];
            if (_data["additionalCounts"]) {
                this.additionalCounts = {} as any;
                for (let key in _data["additionalCounts"]) {
                    if (_data["additionalCounts"].hasOwnProperty(key))
                        (<any>this.additionalCounts)![key] = _data["additionalCounts"][key];
                }
            }
        }
    }

    static fromJS(data: any): Details {
        data = typeof data === 'object' ? data : {};
        let result = new Details();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["inputTokenCount"] = this.inputTokenCount;
        data["outputTokenCount"] = this.outputTokenCount;
        data["totalTokenCount"] = this.totalTokenCount;
        if (this.additionalCounts) {
            data["additionalCounts"] = {};
            for (let key in this.additionalCounts) {
                if (this.additionalCounts.hasOwnProperty(key))
                    (<any>data["additionalCounts"])[key] = (<any>this.additionalCounts)[key];
            }
        }
        return data;
    }
}

export interface IDetails {
    inputTokenCount?: number | undefined;
    outputTokenCount?: number | undefined;
    totalTokenCount?: number | undefined;
    additionalCounts?: { [key: string]: number; } | undefined;

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}